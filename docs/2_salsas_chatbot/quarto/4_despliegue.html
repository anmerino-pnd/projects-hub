<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="es" xml:lang="es"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Despliegue – Angel Merino | Data Portfolio</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-f3c2ea88cadbcfb37ba28ffa2c97cfc1.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Sin resultados",
    "search-matching-documents-text": "documentos encontrados",
    "search-copy-link-title": "Copiar el enlace en la búsqueda",
    "search-hide-matches-text": "Ocultar resultados adicionales",
    "search-more-match-text": "resultado adicional en este documento",
    "search-more-matches-text": "resultados adicionales en este documento",
    "search-clear-button-title": "Borrar",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancelar",
    "search-submit-button-title": "Enviar",
    "search-label": "Buscar"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Angel Merino | Data Portfolio</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Buscar"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Navegación de palanca" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">Inicio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">Sobre Mí</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-proyectos" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Proyectos</span>
    </a>
    <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="nav-menu-proyectos">    
        <li>
    <a class="dropdown-item" href="../../0_cenace_helpdesk/docs/index.html">
 <span class="dropdown-text">Help Desk CENACE</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../1_ct_chatbot/docs/index.html">
 <span class="dropdown-text">Recomendador CT</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../../2_salsas_chatbot/docs/index.html">
 <span class="dropdown-text">Chatbot Salsas Castillo</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Tabla de Contenidos</h2>
   
  <ul>
  <li><a href="#revisión-del-proceso" id="toc-revisión-del-proceso" class="nav-link active" data-scroll-target="#revisión-del-proceso">1. Revisión del Proceso</a>
  <ul class="collapse">
  <li><a href="#determinación-de-próximos-pasos" id="toc-determinación-de-próximos-pasos" class="nav-link" data-scroll-target="#determinación-de-próximos-pasos">1.1. Determinación de Próximos Pasos</a></li>
  <li><a href="#decisión" id="toc-decisión" class="nav-link" data-scroll-target="#decisión">1.2. Decisión</a></li>
  </ul></li>
  <li><a href="#plan-de-implementación" id="toc-plan-de-implementación" class="nav-link" data-scroll-target="#plan-de-implementación">2. Plan de Implementación</a>
  <ul class="collapse">
  <li><a href="#arquitectura-de-despliegue-y-conexión" id="toc-arquitectura-de-despliegue-y-conexión" class="nav-link" data-scroll-target="#arquitectura-de-despliegue-y-conexión">2.1. Arquitectura de Despliegue y Conexión</a></li>
  <li><a href="#gestión-de-persistencia-de-datos-con-mongodb" id="toc-gestión-de-persistencia-de-datos-con-mongodb" class="nav-link" data-scroll-target="#gestión-de-persistencia-de-datos-con-mongodb">2.2. Gestión de Persistencia de Datos con MongoDB</a></li>
  <li><a href="#plan-de-monitoreo" id="toc-plan-de-monitoreo" class="nav-link" data-scroll-target="#plan-de-monitoreo">2.3. Plan de Monitoreo</a></li>
  <li><a href="#plan-de-mantenimiento" id="toc-plan-de-mantenimiento" class="nav-link" data-scroll-target="#plan-de-mantenimiento">2.4. Plan de Mantenimiento</a></li>
  <li><a href="#experiencia-de-desarrollo" id="toc-experiencia-de-desarrollo" class="nav-link" data-scroll-target="#experiencia-de-desarrollo">2.5. Experiencia de Desarrollo</a></li>
  <li><a href="#despliegue-del-chatbot-en-el-sistema-de-pruebas" id="toc-despliegue-del-chatbot-en-el-sistema-de-pruebas" class="nav-link" data-scroll-target="#despliegue-del-chatbot-en-el-sistema-de-pruebas">2.6. Despliegue del Chatbot en el Sistema de Pruebas</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Despliegue</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="revisión-del-proceso" class="level2" style="text-align: justify">
<h2 class="anchored" data-anchor-id="revisión-del-proceso">1. Revisión del Proceso</h2>
<p>El desarrollo del chatbot para Salsas Castillo ha seguido un enfoque iterativo, centrado en la integración de modelos de lenguaje con las bases de datos existentes y la plataforma de Telegram. Los principales retos se concentraron en asegurar la <strong>interacción fluida y precisa del LLM con las bases de datos SQL</strong> para consultas dinámicas, así como la correcta <strong>gestión del historial de conversación y la generación de reportes en PDF</strong>.</p>
<p>El objetivo principal de optimizar el acceso a la información de productos y finanzas se ha mantenido constante a lo largo del proyecto, adaptándose a las particularidades de Salsas Castillo.</p>
<section id="determinación-de-próximos-pasos" class="level3">
<h3 class="anchored" data-anchor-id="determinación-de-próximos-pasos">1.1. Determinación de Próximos Pasos</h3>
<p>Considerando los avances en el desarrollo y las pruebas internas, se ha decidido priorizar el despliegue en un entorno de pruebas real para validar el comportamiento del chatbot en condiciones operativas y recopilar feedback directo de los usuarios.</p>
</section>
<section id="decisión" class="level3">
<h3 class="anchored" data-anchor-id="decisión">1.2. Decisión</h3>
<p>La decisión es proceder con la implementación del chatbot en un entorno de pruebas de Telegram. Esto permitirá:</p>
<ul>
<li><p>Validar la integración completa con la API de Telegram.</p></li>
<li><p>Probar la conectividad y el rendimiento con las bases de datos PostgreSQL y MongoDB en un entorno real.</p></li>
<li><p>Recopilar feedback de usuarios internos para identificar mejoras en la experiencia de usuario y la precisión de las respuestas.</p></li>
<li><p>Asegurar la robustez y estabilidad del sistema antes de una posible implementación a mayor escala.</p></li>
</ul>
</section>
</section>
<section id="plan-de-implementación" class="level2" style="text-align: justify">
<h2 class="anchored" data-anchor-id="plan-de-implementación">2. Plan de Implementación</h2>
<p>La fase de implementación implica el despliegue del backend del chatbot y su integración con la plataforma de Telegram.</p>
<section id="arquitectura-de-despliegue-y-conexión" class="level3">
<h3 class="anchored" data-anchor-id="arquitectura-de-despliegue-y-conexión">2.1. Arquitectura de Despliegue y Conexión</h3>
<p>El chatbot de Salsas Castillo se despliega como un servicio de backend basado en <strong>FastAPI</strong>, que interactúa con la <strong>API de Telegram</strong> mediante <strong>webhooks</strong>. La persistencia de datos se maneja con <strong>MongoDB</strong> y las consultas a datos transaccionales se realizan en <strong>PostgreSQL</strong>.</p>
<ul>
<li><p><strong>Backend del Chatbot (FastAPI)</strong>: La aplicación principal se despliega en un servidor (o ambiente virtual Linux) utilizando Gunicorn para producción o <strong>Uvicorn</strong> para desarrollo.</p></li>
<li><p><strong>Conexión con Telegram</strong>: La comunicación se establece a través de webhooks. Telegram envía las actualizaciones de mensajes al endpoint <code>/webhook</code> de la API de FastAPI. El chatbot, a su vez, utiliza la API de Telegram para enviar respuestas y documentos (PDFs).</p></li>
<li><p><strong>Bases de Datos</strong>:</p>
<ul>
<li><p><strong>PostgreSQL</strong>: Se establece una conexión directa desde el backend del chatbot para las consultas SQL.</p></li>
<li><p><strong>MongoDB</strong>: Se utiliza para almacenar el historial de sesiones (<code>sessions</code>) y un respaldo completo de mensajes (<code>message_backup</code>).</p></li>
</ul></li>
</ul>
</section>
<section id="gestión-de-persistencia-de-datos-con-mongodb" class="level3">
<h3 class="anchored" data-anchor-id="gestión-de-persistencia-de-datos-con-mongodb">2.2. Gestión de Persistencia de Datos con MongoDB</h3>
<p>La gestión del historial de conversaciones es crucial para un chatbot. En Salsas Castillo, se utiliza MongoDB con dos colecciones principales:</p>
<ul>
<li><p><code>sessions</code>: Almacena los últimos mensajes de cada sesión de usuario para mantener el contexto de la conversación. Se configura para mantener un tamaño fijo (ej., los últimos 24 mensajes) para optimizar el rendimiento.</p></li>
<li><p><code>message_backup</code>: Actúa como un histórico completo de todas las interacciones (preguntas del usuario, respuestas del chatbot, metadatos). Es fundamental para el análisis de datos, auditorías y futuras mejoras del modelo.</p></li>
</ul>
</section>
<section id="plan-de-monitoreo" class="level3">
<h3 class="anchored" data-anchor-id="plan-de-monitoreo">2.3. Plan de Monitoreo</h3>
<p>Durante la fase de pruebas, se implementará un plan de monitoreo para evaluar el rendimiento y comportamiento del sistema:</p>
<ul>
<li><p><strong>Tiempo de Respuesta</strong>: Latencia de las respuestas del chatbot, incluyendo el tiempo de ejecución de las consultas SQL y las llamadas a la API de OpenAI.</p></li>
<li><p><strong>Tasa de Éxito/Error</strong>: Monitoreo de las peticiones a la API del chatbot y a las bases de datos.</p></li>
<li><p><strong>Calidad de las Respuestas</strong>: Evaluación manual de la precisión, coherencia y relevancia de las respuestas, especialmente en escenarios complejos o con datos numéricos.</p></li>
<li><p><strong>Uso del Chatbot</strong>: Frecuencia de interacciones por usuario, tipos de consultas más comunes.</p></li>
<li><p><strong>Errores en Logs</strong>: Revisión de los logs del servidor para identificar excepciones o problemas en el backend.</p></li>
</ul>
</section>
<section id="plan-de-mantenimiento" class="level3">
<h3 class="anchored" data-anchor-id="plan-de-mantenimiento">2.4. Plan de Mantenimiento</h3>
<p>Se establecerá un plan de mantenimiento periódico para asegurar la estabilidad y el buen funcionamiento del sistema:</p>
<ul>
<li><p><strong>Actualización de Dependencias</strong>: Revisión y actualización regular de las librerías de Python (FastAPI, LangChain, PyMongo, etc.).</p></li>
<li><p><strong>Revisión de Logs</strong>: Monitoreo activo de los logs del servidor y de las bases de datos para identificar y solucionar problemas.</p></li>
<li><p><strong>Auditoría de Datos y Respuestas</strong>: Evaluación periódica de la calidad de los datos en PostgreSQL y MongoDB, y verificación de la precisión de las respuestas del chatbot a lo largo del tiempo.</p></li>
<li><p><strong>Optimización de Consultas</strong>: Refinamiento continuo de las consultas SQL generadas por el LLM para mejorar el rendimiento.</p></li>
<li><p><strong>Actualización del Vector Store</strong>: Si se añaden nuevos documentos internos, se programará la actualización del vector store FAISS.</p></li>
</ul>
</section>
<section id="experiencia-de-desarrollo" class="level3">
<h3 class="anchored" data-anchor-id="experiencia-de-desarrollo">2.5. Experiencia de Desarrollo</h3>
<p>El proyecto ha permitido consolidar la experiencia en el desarrollo de un chatbot completo, desde la integración con plataformas de mensajería (Telegram) hasta la orquestación de LLMs con bases de datos relacionales y vectoriales. Los aprendizajes clave incluyen:</p>
<ul>
<li><p>Manejo de la interacción entre LLMs y bases de datos SQL para consultas dinámicas.</p></li>
<li><p>Implementación de la persistencia de sesiones y el historial de mensajes en MongoDB.</p></li>
<li><p>Desarrollo de herramientas personalizadas (ej., generación de PDFs) y su integración en el flujo del agente.</p></li>
<li><p>Gestión de la transcripción de audio para una experiencia de usuario más inclusiva.</p></li>
<li><p>Adherencia a buenas prácticas de desarrollo modular y escalable.</p></li>
</ul>
</section>
<section id="despliegue-del-chatbot-en-el-sistema-de-pruebas" class="level3">
<h3 class="anchored" data-anchor-id="despliegue-del-chatbot-en-el-sistema-de-pruebas">2.6. Despliegue del Chatbot en el Sistema de Pruebas</h3>
<p>El chatbot será desplegado en un entorno de pruebas de Telegram, accesible para un grupo controlado de usuarios internos de Salsas Castillo. Este despliegue permitirá validar el sistema en condiciones casi reales.</p>
<p>El proceso de despliegue consistirá en:</p>
<ul>
<li><p><strong>Montaje del Entorno de la API</strong>: Despliegue de la API de FastAPI en un servidor dedicado, asegurando la conectividad con PostgreSQL y MongoDB.</p></li>
<li><p><strong>Configuración del Webhook de Telegram</strong>: Establecer el webhook para que Telegram envíe las actualizaciones de mensajes al endpoint de la API.</p></li>
<li><p><strong>Verificación Funcional</strong>: Realizar pruebas exhaustivas para verificar el flujo de conversación, la precisión de las respuestas, la generación de PDFs y el manejo de la transcripción de audio.</p></li>
<li><p><strong>Consideraciones de Seguridad</strong>: Asegurar la autenticación de usuarios (mediante whitelist de Telegram IDs), el manejo seguro de credenciales y la protección de datos.</p></li>
</ul>
<p>Este hito marca un avance significativo hacia la validación en entorno real del sistema conversacional, permitiendo recopilar feedback de usuarios internos antes de considerar un despliegue completo en producción.</p>
</section>
</section>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copiado");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copiado");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>