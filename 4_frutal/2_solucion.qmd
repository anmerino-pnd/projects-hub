---
title: "Arquitectura y Soluci√≥n T√©cnica"
format: 
    html:
         page-layout: article
toc-title: "Tabla de Contenidos"
toc: true
toc-depth: 5
---

::: {style="text-align: justify"}
## Arquitectura

Para resolver la migraci√≥n de datos desde un entorno hostil (drivers legacy inestables), dise√±√© una arquitectura desacoplada basada en contenedores.

```{mermaid}
%%| fig-align: center
flowchart TB
    A[üóÑÔ∏è Legacy HFSQL Server] -->|ODBC| B(üêç Python Wrapper / Subproceso)
    B -->|Raw Data| C{üê≥ Docker/Podman<br>Container}
    C -->|Pandas Transformation| D[üì¶ Parquet Data Lake]
    D -->|Consumo| E[üìä Dashboard / Analytics]

    style A fill:#2b4c7e,stroke:#2b4c7e,color:#fff,stroke-width:2px
    style B fill:#3a7ca5,stroke:#3a7ca5,color:#fff,stroke-width:2px
    style C fill:#f7b2c4,stroke:#d4819a,color:#333,stroke-width:2px
    style D fill:#88c9a1,stroke:#5fa87a,color:#333,stroke-width:2px
    style E fill:#2b4c7e,stroke:#2b4c7e,color:#fff,stroke-width:2px
```

El pipeline de datos sigue un flujo de extracci√≥n robusto que prioriza la integridad de la memoria y la portabilidad.
:::

::: {style="text-align: justify"}
## Desaf√≠os Cr√≠ticos y Soluciones

### 1. El Problema del "Stack Smashing"
Uno de los mayores obst√°culos t√©cnicos fue la interacci√≥n entre el driver ODBC propietario de HFSQL y las librer√≠as modernas de Linux (`unixODBC`). Al intentar conexiones directas, el driver provocaba corrupciones de memoria (*stack smashing*) que "mataban" el proceso principal de extracci√≥n.

**La Soluci√≥n:**

Implement√© un patr√≥n de **aislamiento de procesos**. En lugar de ejecutar la conexi√≥n ODBC en el hilo principal de la aplicaci√≥n:

* Desarroll√© un **wrapper en Python** que a√≠sla la conexi√≥n inestable en un subproceso independiente.
* Si el driver falla, el proceso principal detecta el error, limpia la memoria y reintenta sin detener todo el pipeline.

### 2. Contenerizaci√≥n con Podman
Dado que el entorno de desarrollo era Windows y el de producci√≥n un servidor Linux "headless", las discrepancias en las librer√≠as din√°micas (DLLs vs .so) eran constantes.

**La Implementaci√≥n:**

Utilic√© **Podman** (una alternativa a Docker sin daemon) para encapsular no solo el c√≥digo Python, sino todo el entorno del sistema operativo necesario para el driver legacy.

* **Imagen Personalizada:** Cre√© una imagen de Linux que incluye versiones espec√≠ficas de librer√≠as antiguas requeridas por el driver HFSQL.
* **Cross-Platform:** Esto garantiz√≥ que el c√≥digo funcionara id√©ntico en mi m√°quina local y en el servidor del cliente.

### 3. Optimizaci√≥n con Parquet

En lugar de volcar los datos a CSV (lento y pesado), utilic√© **Apache Parquet**.

* **Compresi√≥n:** Reducci√≥n del 60% en el tama√±o de almacenamiento.
* **Tipado:** Preservaci√≥n de los tipos de datos (fechas, flotantes) que sol√≠an perderse en exportaciones de texto plano.
:::

::: {style="text-align: justify"}
## Stack Tecnol√≥gico

* **Lenguaje:** Python 3.10
* **Contenedores:** Podman & Docker
* **Drivers:** pyodbc, unixODBC, HFSQL ODBC
* **Data Lake:** Pandas, PyArrow, Parquet

:::
